<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Emu War Arcade — GoPro (Mobile) — Nets & Angry Emus</title>
  <style>
    html, body { margin:0; padding:0; background:#0f1016; color:#e6e6e6; font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif; }
    body { overscroll-behavior: none; }
    #wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:10px; }
    canvas { background:#12131b; border-radius:12px; box-shadow:0 6px 24px rgba(0,0,0,.35); touch-action:none; }
    .row { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; align-items:center; }
    .pill { padding:4px 10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); font-size:14px; opacity:.95;}
    .btn {
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#eaeaea;
      padding:12px 14px;
      border-radius:14px;
      font-size:18px;
      user-select:none; -webkit-user-select:none;
      text-align:center;
      min-width:120px;
    }
    .btn.big { font-size:20px; font-weight:800; letter-spacing:.3px; }
    .btn:active { transform: translateY(1px); background: rgba(255,255,255,.12); }
    .small { font-size:12px; opacity:.85; text-align:center; max-width:min(920px, 96vw); }

    .touchpad-mobile{
      width:min(920px, 96vw);
      display:grid;
      grid-template-columns: 1fr 1.2fr 1fr;
      gap:12px;
      margin-top:6px;
    }
    .touchpad-mobile .col{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .touchpad-mobile .btn{ min-width:0; }
    .touchpad-mobile .btn.fire{ padding:18px 14px; }
  </style>
</head>
<body>
<div id="wrap">
  <div class="row">
    <div class="pill" id="modePill">Mode: —</div>
    <div class="pill" id="scorePill">Score: 0</div>
    <div class="pill" id="timePill">Time: 0.0s</div>
    <div class="pill" id="statusPill">GoPro | Fixed lanes</div>
  </div>

  <canvas id="c" width="900" height="560"></canvas>

  <div class="small" id="helpText">
    Fixed lanes. ◀/▶ change lanes. FIRE throws a net/bag (soldier) or spits (emu).
    Bushes/rocks block projectiles. Angry emus hide, flank, spit, and peck up close.
  </div>

  <div class="row">
    <div class="btn" id="btnSoldier">1: Play as SOLDIER</div>
    <div class="btn" id="btnEmu">2: Play as EMU</div>
    <div class="btn" id="btnRestartTop">Restart</div>
  </div>

  <div class="touchpad-mobile">
    <div class="col left">
      <div class="btn big" id="btnLeft">◀ Lane</div>
      <div class="btn" id="btnRestart">Restart</div>
    </div>

    <div class="col center">
      <div class="btn" id="btnUp">▲</div>
      <div class="btn big fire" id="btnFire">FIRE</div>
      <div class="btn" id="btnDown">▼</div>
    </div>

    <div class="col right">
      <div class="btn big" id="btnRight">Lane ▶</div>
      <div class="btn" id="btnPause">Pause</div>
    </div>
  </div>

  <div class="small">Cartoon parody inspired by the 1932 “Emu War” story. (Cartoon violence.)</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const modePill = document.getElementById('modePill');
  const scorePill = document.getElementById('scorePill');
  const timePill = document.getElementById('timePill');

  const btnSoldier = document.getElementById('btnSoldier');
  const btnEmu = document.getElementById('btnEmu');
  const btnRestartTop = document.getElementById('btnRestartTop');
  const btnRestart = document.getElementById('btnRestart');
  const btnUp = document.getElementById('btnUp');
  const btnDown = document.getElementById('btnDown');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnFire = document.getElementById('btnFire');
  const btnPause = document.getElementById('btnPause');

  const W = canvas.width, H = canvas.height;

  // Colors
  const BG = '#12131b';
  const ROAD = '#262431';
  const ROAD_EDGE = 'rgba(255,255,255,.10)';
  const HUDC = '#e6e6e6';

  const SOLDIER = '#4fb06d';
  const SOLDIER_DARK = '#2f7a46';
  const HELMET = '#3e4a3f';

  const EMU_BODY = '#b7773a';
  const EMU_DARK = '#6a3e1a';
  const EMU_BEAK = '#f2c27b';
  const EMU_EYE = '#f5f5f5';

  const SPIT = '#ff78c8';
  const HIT = '#ff5050';

  const NET = 'rgba(220,220,220,.85)';
  const NET_DARK = 'rgba(120,120,120,.85)';

  const BUSH = '#2e7d55';
  const BUSH_DARK = '#1f5a3d';
  const ROCK = '#5f6674';
  const ROCK_DARK = '#3f4652';

  // Perspective + lanes
  const LANES = 7;
  const horizonY = 86;
  const nearY = H - 95;
  const roadTopW = 190;
  const roadBotW = 860;

  // Terrain scroll
  const worldScroll = 0.11;

  // Caps for mobile stability
  const MAX_OBS = 34;
  const MAX_ENEMIES = 36;
  const MAX_PROJ = 70;

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function randi(a,b){ return Math.floor(rand(a,b+1)); }
  function nowSec(){ return performance.now()/1000; }

  function yFromZ(z){
    const t = z*z;
    return nearY + (horizonY - nearY) * t;
  }
  function halfRoadW(z){
    const t = z*z;
    const w = roadBotW + (roadTopW - roadBotW) * t;
    return w/2;
  }
  function laneCenterX(lane, z){
    const hw = halfRoadW(z);
    const left = W/2 - hw;
    const frac = (lane + 0.5) / LANES;
    return left + frac * (hw*2);
  }
  function laneWidth(z){ return (halfRoadW(z)*2)/LANES; }
  function scaleFromZ(z){ return 0.25 + (1.0 - z) * 1.10; }

  // Inputs
  const input = { left:false, right:false, fire:false, pauseToggle:false, justUp:false, justDown:false };

  function bindHold(button, keyName) {
    const on = (e)=>{ e.preventDefault(); input[keyName]=true; };
    const off = (e)=>{ e.preventDefault(); input[keyName]=false; };
    button.addEventListener('touchstart', on, {passive:false});
    button.addEventListener('touchend', off, {passive:false});
    button.addEventListener('touchcancel', off, {passive:false});
    button.addEventListener('mousedown', on);
    button.addEventListener('mouseup', off);
    button.addEventListener('mouseleave', off);
  }
  function bindTap(button, cb) {
    const on = (e)=>{ e.preventDefault(); cb(); };
    button.addEventListener('touchstart', on, {passive:false});
    button.addEventListener('mousedown', on);
  }

  bindHold(btnLeft, 'left');
  bindHold(btnRight, 'right');
  bindHold(btnFire, 'fire');
  bindTap(btnUp, ()=> input.justUp = true);
  bindTap(btnDown, ()=> input.justDown = true);
  bindTap(btnPause, ()=> input.pauseToggle = true);

  bindTap(btnSoldier, ()=> start('soldier'));
  bindTap(btnEmu, ()=> start('emu'));
  bindTap(btnRestart, ()=> resetToMenu());
  bindTap(btnRestartTop, ()=> resetToMenu());

  window.addEventListener('keydown', (e)=>{
    if (e.code === 'ArrowLeft') input.left = true;
    if (e.code === 'ArrowRight') input.right = true;
    if (e.code === 'ArrowUp') input.justUp = true;
    if (e.code === 'ArrowDown') input.justDown = true;
    if (e.code === 'Space') input.fire = true;
    if (e.code === 'Escape') input.pauseToggle = true;
    if (e.code === 'Digit1') start('soldier');
    if (e.code === 'Digit2') start('emu');
    if (e.code === 'KeyR') resetToMenu();
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'ArrowLeft') input.left = false;
    if (e.code === 'ArrowRight') input.right = false;
    if (e.code === 'Space') input.fire = false;
  });

  // State
  let state = 'menu'; // menu | play | gameover
  let mode = null;    // soldier | emu
  let paused = false;

  let score = 0;
  let t = 0;
  let lastT = nowSec();

  const enemies = [];
  const projectiles = [];
  const obstacles = [];

  const player = {
    lane: 3,
    z: 0.03,
    hp: 10,
    maxHp: 10,
    cd: 0,
    laneCd: 0,
    hitFlash: 0
  };

  function resetToMenu(){
    state='menu'; mode=null; paused=false;
    score=0; t=0;
    enemies.length=0; projectiles.length=0; obstacles.length=0;
    modePill.textContent = 'Mode: —';
    scorePill.textContent = 'Score: 0';
    timePill.textContent = 'Time: 0.0s';
  }

  function start(which){
    mode = which;
    state = 'play';
    paused = false;
    score = 0;
    t = 0;
    enemies.length=0; projectiles.length=0; obstacles.length=0;

    player.lane = 3;
    player.z = 0.03;
    player.cd = 0;
    player.laneCd = 0;
    player.hitFlash = 0;

    if (mode === 'soldier') { player.maxHp = 10; player.hp = 10; }
    else { player.maxHp = 12; player.hp = 12; }

    spawnObstacleRow(0.92);
    spawnObstacleRow(0.82);
    spawnObstacleRow(0.72);

    modePill.textContent = `Mode: ${mode.toUpperCase()}`;
    scorePill.textContent = `Score: ${score}`;
    timePill.textContent = `Time: ${t.toFixed(1)}s`;
  }

  // Obstacles
  function spawnObstacleRow(z){
    const count = (Math.random()<0.55) ? 2 : 3;
    const taken = new Set();
    for (let i=0;i<count;i++){
      let lane;
      do { lane = randi(0, LANES-1); } while(taken.has(lane));
      taken.add(lane);
      const type = (Math.random()<0.55) ? 'bush' : 'rock';
      obstacles.push({ type, lane, z, r: rand(0.62, 0.92) });
    }
  }
  function obstacleBlocksShot(lane, zFrom, zTo){
    const zMin = Math.min(zFrom, zTo);
    const zMax = Math.max(zFrom, zTo);
    for (const o of obstacles){
      if (o.lane !== lane) continue;
      if (o.z >= zMin - 0.010 && o.z <= zMax + 0.010) return true;
    }
    return false;
  }

  // Enemies
  function spawnEnemy(){
    const farZ = rand(0.84, 0.99);
    const lane = randi(0, LANES-1);

    if (mode === 'soldier'){
      // Angry EMU
      enemies.push({
        type:'emu',
        lane,
        z: farZ,
        hp: (t>60?4:(t>25?3:2)),
        maxHp: (t>60?4:(t>25?3:2)),
        speed: 0.105 + Math.min(0.14, t/700),
        shootCd: rand(0.8, 1.6),
        peckCd: rand(0.5, 1.2),
        state:'advance',
        hideZ: 0,
        hideT: 0,
        angry: true,
        hitFlash:0
      });
    } else {
      // Soldier enemy throws nets
      enemies.push({
        type:'soldier',
        lane,
        z: farZ,
        hp: (t>60?4:(t>25?3:2)),
        maxHp: (t>60?4:(t>25?3:2)),
        speed: 0.095 + Math.min(0.14, t/750),
        shootCd: rand(0.9, 1.8),
        state:'advance',
        hitFlash:0
      });
    }
  }

  // Projectiles
  // kind: 'spit' or 'net'
  function enemyShoot(e){
    if (mode === 'soldier'){
      // emu spits toward player
      projectiles.push({ owner:'enemy', kind:'spit', lane:e.lane, z:e.z, vz: -0.52, dmg:1, ttl: 2.1 });
      e.shootCd = rand(0.9, 1.8);
    } else {
      // soldier throws net toward player
      projectiles.push({ owner:'enemy', kind:'net', lane:e.lane, z:e.z, vz: -0.46, dmg:1, ttl: 2.2 });
      e.shootCd = rand(1.0, 2.1);
    }
  }

  function playerShoot(){
    if (player.cd > 0) return;
    if (mode === 'soldier'){
      // soldier throws net/bag forward
      projectiles.push({ owner:'player', kind:'net', lane:player.lane, z:player.z, vz: +0.62, dmg:2, ttl: 2.0 });
      player.cd = 0.22;
    } else {
      // emu spits forward
      projectiles.push({ owner:'player', kind:'spit', lane:player.lane, z:player.z, vz: +0.70, dmg:1, ttl: 2.0 });
      player.cd = 0.18;
    }
  }

  function hitAtLaneZ(aLane, aZ, bLane, bZ, zTol){
    return aLane === bLane && Math.abs(aZ - bZ) <= zTol;
  }

  // Surround condition (emurs win by surrounding soldier)
  function checkSurround(){
    if (mode !== 'soldier') return false;
    const near = 0.12;
    let left=false, right=false, mid=false;
    for (const e of enemies){
      if (e.type !== 'emu') continue;
      if (e.z > near) continue;
      if (e.lane === player.lane) mid = true;
      if (e.lane === player.lane - 1) left = true;
      if (e.lane === player.lane + 1) right = true;
    }
    return left && right && mid;
  }

  // Timers
  let spawnTimer = 0.0;
  let obsTimer = 0.0;

  function update(dt){
    if (input.pauseToggle){ paused = !paused; input.pauseToggle=false; }
    if (paused) return;

    t += dt;

    player.cd = Math.max(0, player.cd - dt);
    player.laneCd = Math.max(0, player.laneCd - dt);
    player.hitFlash = Math.max(0, player.hitFlash - dt);

    // Fixed lane controls
    if (player.laneCd === 0){
      if (input.left || input.justUp){
        player.lane = Math.max(0, player.lane - 1);
        player.laneCd = 0.12;
      } else if (input.right || input.justDown){
        player.lane = Math.min(LANES - 1, player.lane + 1);
        player.laneCd = 0.12;
      }
    }
    input.justUp = false;
    input.justDown = false;

    if (input.fire) playerShoot();

    // Scroll obstacles + delete old (prevents freeze)
    for (let i = obstacles.length - 1; i >= 0; i--){
      obstacles[i].z -= worldScroll * dt;
      if (obstacles[i].z <= 0.02) obstacles.splice(i, 1);
    }

    // Spawn enemies
    const base = (mode === 'soldier') ? 0.92 : 1.05;
    const ramp = Math.max(0.45, base - t/150);
    spawnTimer -= dt;
    if (spawnTimer <= 0){
      if (enemies.length < MAX_ENEMIES) spawnEnemy();
      spawnTimer = ramp + rand(-0.12, 0.18);
    }

    // Spawn obstacles far away
    obsTimer -= dt;
    if (obsTimer <= 0){
      if (obstacles.length < MAX_OBS) spawnObstacleRow(rand(0.86, 0.99));
      obsTimer = 3.0 + rand(-0.6, 1.2);
    }

    // Enemy AI
    for (const e of enemies){
      e.hitFlash = Math.max(0, e.hitFlash - dt);
      e.shootCd = Math.max(0, e.shootCd - dt);

      if (e.type === 'emu'){
        e.peckCd = Math.max(0, e.peckCd - dt);

        // hide near an obstacle in same lane
        const cover = obstacles.find(o => o.lane === e.lane && o.z < e.z && (e.z - o.z) < 0.24);
        if (cover && e.z > 0.34 && Math.random() < 0.014){
          e.state = 'hide';
          e.hideZ = cover.z + 0.03;
          e.hideT = 0;
        }

        // flanking + trying to surround
        if (e.z > 0.18 && Math.random() < (0.018 + Math.min(0.028, t/2300))){
          const dir = (player.lane < e.lane) ? -1 : (player.lane > e.lane ? 1 : (Math.random()<0.5?-1:1));
          e.lane = clamp(e.lane + dir, 0, LANES-1);
          e.state = 'flank';
        }

        // Movement
        if (e.state === 'hide'){
          if (e.z > e.hideZ) e.z -= e.speed * dt * 0.35;
          else {
            e.hideT += dt;
            if (e.hideT > 0.65){
              e.state = 'advance';
              e.hideT = 0;
              if (e.shootCd === 0 && Math.random() < 0.85) enemyShoot(e);
            }
          }
        } else {
          e.z -= e.speed * dt;
        }

        // Spit (ranged)
        if (e.shootCd === 0 && Math.random() < 0.62){
          enemyShoot(e);
        }

        // Peck (melee) if close enough
        if (e.peckCd === 0 && e.z <= 0.10 && Math.abs(e.lane - player.lane) <= 0){
          player.hp -= 1;
          player.hitFlash = 0.12;
          e.peckCd = rand(0.55, 0.95);
        }

      } else {
        // soldier enemy
        e.z -= e.speed * dt;

        // throw net sometimes
        if (e.shootCd === 0 && Math.random() < 0.58){
          enemyShoot(e);
        }
      }
    }

    // Projectiles move + obstacles block
    for (const p of projectiles){
      const zPrev = p.z;
      p.z += p.vz * dt;
      p.ttl -= dt;
      if (obstacleBlocksShot(p.lane, zPrev, p.z)) p.ttl = -1;
    }

    // Projectile hits
    for (let i=projectiles.length-1; i>=0; i--){
      const p = projectiles[i];
      if (p.ttl <= 0) { projectiles.splice(i,1); continue; }

      if (p.owner === 'enemy'){
        if (hitAtLaneZ(p.lane, p.z, player.lane, player.z, 0.04)){
          // nets or spit hit player
          player.hp -= p.dmg;
          player.hitFlash = 0.12;
          projectiles.splice(i,1);
          continue;
        }
      } else {
        for (let j=enemies.length-1; j>=0; j--){
          const e = enemies[j];
          const zTol = 0.05 + (1-e.z)*0.03;
          if (hitAtLaneZ(p.lane, p.z, e.lane, e.z, zTol)){
            e.hp -= p.dmg;
            e.hitFlash = 0.12;
            projectiles.splice(i,1);
            if (e.hp <= 0){
              score += 10;
              enemies.splice(j,1);
            }
            break;
          }
        }
      }
    }

    // Enemies reaching camera damage player
    for (let i=enemies.length-1; i>=0; i--){
      const e = enemies[i];
      if (e.z <= 0.02){
        player.hp -= 2;
        player.hitFlash = 0.18;
        enemies.splice(i,1);
      }
    }

    // Cleanup projectiles
    for (let i=projectiles.length-1; i>=0; i--){
      const p = projectiles[i];
      if (p.ttl <= 0 || p.z < -0.2 || p.z > 1.25) projectiles.splice(i,1);
    }

    // Hard caps (mobile safety)
    if (obstacles.length > MAX_OBS) obstacles.splice(0, obstacles.length - MAX_OBS);
    if (enemies.length > MAX_ENEMIES) enemies.splice(0, enemies.length - MAX_ENEMIES);
    if (projectiles.length > MAX_PROJ) projectiles.splice(0, projectiles.length - MAX_PROJ);

    // Surround win
    if (checkSurround()) player.hp = 0;

    if (player.hp <= 0) state = 'gameover';

    scorePill.textContent = `Score: ${score}`;
    timePill.textContent = `Time: ${t.toFixed(1)}s`;
  }

  // --- Drawing ---
  function drawRoad(){
    const topHalf = roadTopW/2;
    const botHalf = roadBotW/2;

    ctx.fillStyle = ROAD;
    ctx.beginPath();
    ctx.moveTo(W/2 - topHalf, horizonY);
    ctx.lineTo(W/2 + topHalf, horizonY);
    ctx.lineTo(W/2 + botHalf, nearY + 70);
    ctx.lineTo(W/2 - botHalf, nearY + 70);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = ROAD_EDGE;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2 - topHalf, horizonY);
    ctx.lineTo(W/2 - botHalf, nearY + 70);
    ctx.moveTo(W/2 + topHalf, horizonY);
    ctx.lineTo(W/2 + botHalf, nearY + 70);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    for (let i=1; i<LANES; i++){
      const frac = i / LANES;
      const xTop = (W/2 - topHalf) + frac * (topHalf*2);
      const xBot = (W/2 - botHalf) + frac * (botHalf*2);
      ctx.beginPath();
      ctx.moveTo(xTop, horizonY);
      ctx.lineTo(xBot, nearY + 70);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawHP(x,y,w,hp,maxHp){
    ctx.fillStyle = 'rgba(255,255,255,.18)';
    ctx.fillRect(x-w/2, y, w, 6);
    const fill = Math.max(0, Math.floor(w * (hp / Math.max(1,maxHp))));
    ctx.fillStyle = '#78ff78';
    ctx.fillRect(x-w/2, y, fill, 6);
  }

  function drawEmu(x,y,s,flash,hp,maxHp,angry,phase){
    // phase drives head bob
    const bob = Math.sin(phase) * 4;         // pixels in local coords
    const neckWob = Math.sin(phase*1.15) * 1.6;

    ctx.save();
    ctx.translate(x,y);
    ctx.scale(s,s);

    // body
    ctx.fillStyle = flash ? HIT : EMU_BODY;
    ctx.beginPath();
    ctx.ellipse(0, 8, 22, 14, 0, 0, Math.PI*2);
    ctx.fill();

    // neck (bobbing)
    ctx.strokeStyle = flash ? HIT : EMU_DARK;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(10, 4);
    ctx.quadraticCurveTo(22 + neckWob, -10 + bob*0.2, 14 + neckWob, -26 + bob);
    ctx.stroke();

    // head
    ctx.fillStyle = flash ? HIT : EMU_DARK;
    ctx.beginPath();
    ctx.ellipse(14 + neckWob, -28 + bob, 9, 7, 0.2, 0, Math.PI*2);
    ctx.fill();

    // beak
    ctx.fillStyle = EMU_BEAK;
    ctx.beginPath();
    ctx.moveTo(22 + neckWob, -28 + bob);
    ctx.lineTo(33 + neckWob, -24 + bob);
    ctx.lineTo(22 + neckWob, -22 + bob);
    ctx.closePath();
    ctx.fill();

    // eye
    ctx.fillStyle = EMU_EYE;
    ctx.beginPath();
    ctx.arc(16 + neckWob, -30 + bob, 2.2, 0, Math.PI*2);
    ctx.fill();

    // angry brows (frowned)
    if (angry){
      ctx.strokeStyle = '#1a0f08';
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      ctx.moveTo(12 + neckWob, -34 + bob);
      ctx.lineTo(18 + neckWob, -32 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(18.5 + neckWob, -34 + bob);
      ctx.lineTo(23 + neckWob, -32 + bob);
      ctx.stroke();
    }

    // legs
    ctx.strokeStyle = flash ? HIT : '#3a2a1b';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, 18); ctx.lineTo(-10, 30);
    ctx.moveTo(6, 18);  ctx.lineTo(6, 31);
    ctx.stroke();

    ctx.restore();
    drawHP(x, y - 34*s, 52*s, hp, maxHp);
  }

  function drawSoldier(x,y,s,flash,hp,maxHp,phase){
    // phase adds subtle bob (like stepping)
    const step = Math.sin(phase) * 2.2;

    ctx.save();
    ctx.translate(x,y);
    ctx.scale(s,s);

    // body
    ctx.fillStyle = flash ? HIT : SOLDIER;
    ctx.fillRect(-14, -4 + step*0.3, 28, 32);

    // belt
    ctx.fillStyle = flash ? HIT : SOLDIER_DARK;
    ctx.fillRect(-14, 12 + step*0.3, 28, 6);

    // head
    ctx.fillStyle = flash ? HIT : '#d8c7a6';
    ctx.beginPath();
    ctx.arc(0, -14 + step*0.25, 10, 0, Math.PI*2);
    ctx.fill();

    // helmet
    ctx.fillStyle = HELMET;
    ctx.beginPath();
    ctx.ellipse(0, -18 + step*0.25, 12, 8, 0, Math.PI, Math.PI*2);
    ctx.fill();
    ctx.fillRect(-12, -18 + step*0.25, 24, 6);

    // net bag (no gun)
    ctx.fillStyle = flash ? HIT : 'rgba(230,230,230,.9)';
    ctx.beginPath();
    ctx.ellipse(14, 10 + step*0.2, 8, 10, 0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(140,140,140,.9)';
    ctx.fillRect(10, 0 + step*0.2, 8, 4);

    ctx.restore();
    drawHP(x, y - 36*s, 52*s, hp, maxHp);
  }

  function drawBush(x,y,s){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);

    ctx.fillStyle = BUSH;
    ctx.beginPath(); ctx.arc(-18, 0, 18, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(0, -8, 22, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(20, 0, 18, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = BUSH_DARK;
    ctx.beginPath(); ctx.arc(-8, 6, 14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(12, 8, 13, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawRock(x,y,s){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);

    ctx.fillStyle = ROCK;
    ctx.beginPath();
    ctx.moveTo(-24, 10);
    ctx.quadraticCurveTo(-30, -6, -12, -16);
    ctx.quadraticCurveTo(0, -24, 18, -16);
    ctx.quadraticCurveTo(34, -4, 24, 14);
    ctx.quadraticCurveTo(0, 26, -24, 10);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = ROCK_DARK;
    ctx.beginPath();
    ctx.moveTo(-10, 8);
    ctx.quadraticCurveTo(-6, -4, 6, -8);
    ctx.quadraticCurveTo(12, 0, 10, 12);
    ctx.quadraticCurveTo(0, 14, -10, 8);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawObstacle(o){
    const y = yFromZ(o.z);
    const x = laneCenterX(o.lane, o.z);
    const s = scaleFromZ(o.z) * o.r;
    if (o.type === 'bush') drawBush(x, y + 18*s, s);
    else drawRock(x, y + 22*s, s * 0.95);
  }

  function drawNetProjectile(p){
    const y = yFromZ(p.z);
    const x = laneCenterX(p.lane, p.z);
    const s = scaleFromZ(p.z);

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);

    // net ring
    ctx.strokeStyle = NET;
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI*2);
    ctx.stroke();

    // criss-cross mesh
    ctx.strokeStyle = NET_DARK;
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(-10, -4); ctx.lineTo(10, 4);
    ctx.moveTo(-10, 4);  ctx.lineTo(10, -4);
    ctx.moveTo(0, -7);   ctx.lineTo(0, 7);
    ctx.stroke();

    ctx.restore();
  }

  function drawSpitProjectile(p){
    const y = yFromZ(p.z);
    const x = laneCenterX(p.lane, p.z);
    const s = scaleFromZ(p.z);
    ctx.fillStyle = SPIT;
    ctx.beginPath();
    ctx.arc(x, y, 5*s, 0, Math.PI*2);
    ctx.fill();
  }

  function drawCentered(lines, yStart){
    ctx.fillStyle = HUDC;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = '28px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(lines[0], W/2, yStart);
    ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    for (let i=1;i<lines.length;i++){
      ctx.fillText(lines[i], W/2, yStart + 42 + (i-1)*24);
    }
  }

  function drawRoad(){
    const topHalf = roadTopW/2;
    const botHalf = roadBotW/2;

    ctx.fillStyle = ROAD;
    ctx.beginPath();
    ctx.moveTo(W/2 - topHalf, horizonY);
    ctx.lineTo(W/2 + topHalf, horizonY);
    ctx.lineTo(W/2 + botHalf, nearY + 70);
    ctx.lineTo(W/2 - botHalf, nearY + 70);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = ROAD_EDGE;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2 - topHalf, horizonY);
    ctx.lineTo(W/2 - botHalf, nearY + 70);
    ctx.moveTo(W/2 + topHalf, horizonY);
    ctx.lineTo(W/2 + botHalf, nearY + 70);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    for (let i=1; i<LANES; i++){
      const frac = i / LANES;
      const xTop = (W/2 - topHalf) + frac * (topHalf*2);
      const xBot = (W/2 - botHalf) + frac * (botHalf*2);
      ctx.beginPath();
      ctx.moveTo(xTop, horizonY);
      ctx.lineTo(xBot, nearY + 70);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);

    const grad = ctx.createLinearGradient(0,0,0,220);
    grad.addColorStop(0, 'rgba(180,180,255,.14)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,240);

    drawRoad();

    if (state === 'menu'){
      drawCentered([
        'EMU WAR ARCADE — Nets & Angry Emus',
        'Tap 1 for Soldier (nets) or 2 for Emu (spit)',
        'Angry emus hide + flank + spit + peck. Bushes/rocks block shots.'
      ], 150);
      return;
    }

    // Sort in place (mobile friendly)
    obstacles.sort((a,b)=> b.z - a.z);
    enemies.sort((a,b)=> b.z - a.z);
    projectiles.sort((a,b)=> b.z - a.z);

    for (const o of obstacles) drawObstacle(o);

    for (const e of enemies){
      const y = yFromZ(e.z);
      const x = laneCenterX(e.lane, e.z);
      const s = scaleFromZ(e.z) * 0.95;
      const phase = (t*8.0) + e.z*10.0;
      if (e.type === 'emu') drawEmu(x, y, s, e.hitFlash>0, e.hp, e.maxHp, e.angry, phase);
      else drawSoldier(x, y, s, e.hitFlash>0, e.hp, e.maxHp, phase);
    }

    for (const p of projectiles){
      if (p.kind === 'net') drawNetProjectile(p);
      else drawSpitProjectile(p);
    }

    // player
    {
      const y = yFromZ(player.z);
      const x = laneCenterX(player.lane, player.z);
      const s = scaleFromZ(player.z) * 1.08;
      const phase = (t*8.0) + player.z*11.0;
      if (mode === 'soldier') drawSoldier(x, y, s, player.hitFlash>0, player.hp, player.maxHp, phase);
      else drawEmu(x, y, s*1.05, player.hitFlash>0, player.hp, player.maxHp, true, phase);
    }

    if (paused){
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      drawCentered(['PAUSED', 'Tap Pause to resume.'], 200);
    }

    if (state === 'gameover'){
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      drawCentered(['GAME OVER', `Final score: ${score}`, 'Tap Restart (or press R).'], 190);
    }
  }

  function loop(){
    const cur = nowSec();
    let dt = cur - lastT;
    lastT = cur;
    dt = Math.min(0.033, dt);

    if (state === 'play') update(dt);
    render();

    requestAnimationFrame(loop);
  }

  resetToMenu();
  lastT = nowSec();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
